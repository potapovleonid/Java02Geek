package ru.gb.jt.network;

import java.net.ServerSocket;
import java.net.Socket;

public interface ServerSocketThreadListener {
    void onServerStart(ServerSocketThread thread);
    void onServerStop(ServerSocketThread thread);
    void onServerSocketCreated(ServerSocketThread thread, ServerSocket server);
    void onServerTimeout(ServerSocketThread thread, ServerSocket server);
    void onSocketAccepted(ServerSocketThread thread, ServerSocket server, Socket socket);
    void onServerException(ServerSocketThread thread, Throwable exception);
}

/*
//почему-то в первый раз нормально отрабатывает, показывает диалоговое окно с сообщением
//и ждет, когда пользователь нажмет "Ок". Все последующие разы окно с сообщением просто
//промелькивает на экране. Подскажите, в чем дело? Может что-то в недрах реализации JOptionPane?
JOptionPane.showMessageDialog(null, msg, "Exception", JOptionPane.ERROR_MESSAGE);

Показать в коде весь путь отправки сообщения

Иван, можете еще раз проговорить, как происходит аутентификация по логину и паролю в нашем чате, с момента, когда логин и пароль вводится со стороны ClientGUI и как реагирует ChatServer на данный запрос.
В классе SqlClient в методе connect показано, как подключить базу SQLite, которая выведена в отдельный файл базы, доступный для пользователя. Каким образом можно подключить базу данных MySQL?
Из урока le по потокам. Можете еще раз объяснить, почему 3000000 получилось при работе потоков в цикле for i= 0 до i < 1000000. В какой момент потоки просуммировались?
При вызове SocketThread из метода Connect() в классе ClientGUI вызывается метод onReceiveString переопределённый в ClientGUI, как мы попадаем в аналогичный метод класса ChatServer посредством которого выводится информация о подключившемся пользователе для всех?
ClientGUI
1. Не реализована кнопка Disconnect, при нажатии на нее ничего не происходит, хотя код полностью рабочий
2. Не до конца понял строку thread.sendMessage(Library.getAuthRequest(login, password));, как мы вызывает метод sendMessage у нашего потока передавая в него строку с "вызовом метода library с параметрами логин и пароль"?
ServerGUI
1. как правильно понять строку private final ChatServer chatServer = new ChatServer(this::onChatServerMessage); при создании константы мы сразу определяем у него слушателя или вызываем метод у chatServer?

Для каждого типа базы данных будет свой JDBC? То есть например для БД Oracle будет своя jar библиотека, которую нужно будет подключить в проект?
Есть ли другие способы форматирования текста в кнопке помимо html тегов (new JButton("<html><b>Disconnect</b><html>")) ?
Понятно, что не говорили про первичные ключи, но наверно логин (login) в таблице clients в БД должен быть ключем или хотя бы уникальным полем ? (чтобы гарантировано логин был неповторяющимся)
Зачем закрывать (close()) поток (Thread) в методе msgFormatError класса ClienThread? По сути просто не можем разобрать, что за сообщение пришло.
(скорее небольшая доработка, которую можно и не вносить) В методе sendToAllAuthorizedClient можно отправлять сообщение все клиентам, кроме самого клиента, которое это сообщение отправил, но нужно будет немного изменить код. У клиента, отправившего сообщение, просто пишем само сообщение в лог(текст ареа). Или лучше так не заморачиваться?

1. В каком случае может произойти /msg_format_error±msg ?
2. SQLException - это исключение нужно как-нибудь обработать?
3. С Vector лучше работать, когда много потоков, а с ArrayList - когда один поток?
   Я правильно понимаю, что это связано только с синхронизацией (Vector)?

После нажатия кнопки disconnect в клиентском окне ничего не происходит. После отключения сервера сообщения продолжают отправляться, а эхо возвращаться. Несколько раз просмотрел код, не могу понять, в чем проблема.

Пожалуйста покажите на занятии как запустить приложение чтобы оно полностью работало (сервер. БД, ГУИ и другие классы)
Как быстро открывать описание встроенных методов?
Как работает метод getNickname в классе SqlClient?
Почему слушатели являются нтерфейсами, а не классами?

В текущей реализации дисконнекта все равно происходят исключения. Как правильно сделать что бы их не возникало?

Добрый день, Иван! Вот несколько вопросов с моей стороны:
1. ChatServer, 102-я строка:
@Override
public void onReceiveString(SocketThread thread, Socket socket, String msg) {
ClientThread client = (ClientThread) thread; - Видимо, прослушал в лекции: что здесь происходит? Это приведение типов нужно для того,
                                              чтобы выделить поток для нового клиента?
                                              Почему нельзя написать что-то типа ... = new SocketThread(this, name(?), socket)?
                                              Из-за того, что в ClientThread свои поля добавлены?
                                              Тот же вопрос относится к 71-й строке метода onSocketAccepted:
                                              @Override
                                              public void onSocketAccepted(ServerSocketThread thread, ServerSocket server, Socket socket) {
                                              putLog("Client connected");
                                              String name = "Socket Thread " + socket.getInetAddress() + ":" + socket.getPort();
                                         ->   new ClientThread(this, name, socket);
2. Как работает метод isAuthorized? Он возвращает значение булевой переменной, но что именно на нее влияет? По умолчанию она false, то есть получается,
что из строки 103-106 мы сразу переходим в метод handleNonAuthorizedMessage, в котором собственно и производится сличение по связке login/ password?
3. ClientGUI, 92-строка, метод actionPerformed: else if (src == btnDisconnect) {
                                               socketThread.close(); }
                                               Я правильно понимаю, что на btnDisconnect у нас не был прописан addActionListener....?
4. Вообще вопросов, конечно, гораздо больше, причем на некоторые из них вы уже ответили, но ответы позабыты, а пересматривать
все 4-х часовые лекции иногда просто нет физической возможности (меток в видеофайлах нет, на поиск слишком много времени тратится, а ваш совет вести конспект, конечно, не всегда работает :)
Но вот вопрос, который неотступно терзает меня на протяжении всех последних лекций, я все же задам: почему был избран именно такой путь? Новичок приходит в шахматный клуб, ему старшие товарищи показывают
сложный дебют и рассчитывают на реакцию что-то типа крайнего удивления со священным трепетом, а новичок такой: ээээ, ребята, а лошадью-то куда ходить?
Я не ожидаю от вас развернутого ответа (по-правде, говоря вообще не ожидаю ответа), просто надеюсь, что вы немного иначе задумаетесь о вверенных в ваши руки
неоперившихся птенцах, которые программирование начали изучать всего несколько месяцев назад. Они отнюдь не глупы и многие из них искренно хотят научиться,
но на определенной стадии развития требовать от них слишком многого, возможно, неразумно. А главное - птенец рискует просто выпасть из гнезда ... Кто-о скажет, мол, невелика потеря,
выживают только наиболее приспособленные, но мне кажется, такой подход ошибочен ;) Спасибо!

1. Поясните пожалуйста еще раз, как формируется сообщение в Library о подключении.
2. В моем ДЗ сообщение почему-то при подключении формируется как: TYPE_BROADCAST, хотя клиент подключился.

1. Почему отправленное сообщение выводится 2 раза подряд?
2. Как запустить несколько клиентов на одном компе? Запуск через java ClientGUI приводит к ошибке Error: Could not find or load main class ClientGUI. Пробовал гуглить и исправить ее, но не получилось.

По-прежнему не очень понятно как это можно написать с нуля

Почему при подключении к серверу с неправильным паролем/логином вылетает exception?

* */