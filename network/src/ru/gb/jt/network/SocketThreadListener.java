package ru.gb.jt.network;

import java.net.Socket;

public interface SocketThreadListener {
    void onSocketStart(SocketThread thread, Socket socket);
    void onSocketStop(SocketThread thread);

    void onSocketReady(SocketThread thread, Socket socket);
    void onReceiveString(SocketThread thread, Socket socket, String msg);

    void onSocketException(SocketThread thread, Exception exception);
}

/*
почему у сервера только номер порта, а у клиента указан и ip и порт? или ip нужен для того, чтобы сервер понимал кому именно отправить то или иное сообщение(либо от другого клиента,либо какую то рассылку)?

1. В методах интерфейса: в некоторых передаетсятолько поток, а в некоторых и поток и сокет. (Хотя вроде для каждого сокета создается свой поток.) Поэтому вопрос зачем передавать обе переменные. Пока в нашем коде переопределенные методы не используют эти переменные, кроме методов exception.
2. Когда закрываю онко клиента без disconnect, т.к. без закрытия потока, вываливаетяс SocketException, хотя я его и добавил. Сделал скриншот, тут добавить нет возможности. Отправлю через телегу.
3.2 вопрос решил добавив в класс ClientGUI интерфейс Closable. Ошибка пропала. Правильно ли сделал или нужно было как-то по другому?

1. При реализации кнопки Disconnect использовал метод socketThread.close(). При его вызове появляется исключение. Бросает его вроде бы клиент, т.к. именно над ним появляется модальное окно с текстом. Но описание ошибки появляется в консоли сервера:
java.io.EOFException
at java.base/java.io.DataInputStream.readUnsignedShort(DataInputStream.java:345)
at java.base/java.io.DataInputStream.readUTF(DataInputStream.java:594)
at java.base/java.io.DataInputStream.readUTF(DataInputStream.java:569)
at ru.gb.network.SocketThread.run(SocketThread.java:29)
В консоли клиента сообщение: "INTERRUPTED while loading Image".
При первом разрыве соединения окно с ошибкой висит до нажатия кнопки "ОК". При последующих разрывах соединений окно появляется "мельком". Причина в том, что не корректно прерывается обработка входного потока сервера? Что именно происходит?
2. После остановки сервера эхо сообщений от клиента по-прежнему приходят. Как будто бы сервер работает. При повторной остановке появляется сообщение, что сервер остановлен.  Но эхо приходит. Почему поток сервера не останавливается?


Когда нам необходимо было слушать действия СерверСокетТреда/СокетТред, мы решили не передавать экземпляр сервера, а передавать экземпляр класса с интерфейсом (что по сути получилось тоже самое).
Для чего это сделано? Чтобы СерверСокетТред/СокетТред не имел доступ к другим методам класса сервера?
Данные полученные сокетом можно прочитать только InputStream'ом?


При старте сервера создается ServerSocket и socket от сервера, а при нажатии кнопки login в ChatGUI создается сокет со стороны пользователя, после этого они связываются, и сразу же создается новый socket со стороны сервера? Или сервер просто слушает и при попытке подключения клиентом, создается сокет который подключается к ожидающему сокету клиента?
При установке Timeout, само выполнение Accept() не прерывается? и просто дается промежуток на обработку новых результатов?
Не очень понял откуда и куда летят сообщения, понятно что из out в in, но где отправная точка? В клиенте GUI? Он доходит до SocketThread и уходит на вход SocketThread сервера? Как понять обработал письмо сервер или нет?

При коннекте клиента видим: Socket Thread /127.0.0.1:64445 ВОПРОС: Почему порт 64445 а не 8189 ?
Отсылаю сообщение в любом клиенте: вижу эхо в логе только у того клиента, который это сообщение послал. У другого клиента в лог ничего не приходит. Почему? Ведь оба клиента слушают порт сервера и сервер должен всем всё отправить…
Почему сделали boolean метод public synchronized boolean sendMessage(String msg) в SocketThread и не использовали ни разу возвращаемое значение? На будущее?
Запускаем ChatClient не подсоединившить к серверу. Пишем сообщение и жмём SEND. Вываливаются исключения NPE. Как лучше их обработать? В методе sendmessage() обернуть socketThread.sendMessage(msg) траем или просто пробросить в методе исключение и обрабатывать вне его?

1.1.Насколько хорошо нужно продумывать архитектуру приложения при разработке (на примере чата)?
1.2.На какие моменты стоит образать внимание при ее (архитектуры) описаниии (разработке)?
1.3.Каковы будут последствия, в случае если архитектура не абстрагирована (направлена на решение конкретной задачи) и сложно ли будет внести изменения?
2.Что произойдет, если сервер попытается запуститься на зарезервированном порте или уже открытом? придется искать любой другой незанятый? и как тогда клиент узнает, что нужно подключиться к другому порту?
3.Каким образом подключиться к серверу, у которого ip динамический, то есть менятся периодически? или все чаты/мессенджеры пишутся из расчета того, что ip адрес статический?
4.В случае с методом sendMessage (из урока) понятно, что он должен быть synchronized, чтобы сообщения появлялись в логе по очереди, а не лезли друг на друга, но непонятно чем грозит, то что метод close не будет synchronized? (Вроде бы получается просто прерываем поток и закрываем сокет, какие здесь могут возникнуть проблемы?)

1. Хотелось бы получить логические умозаключения как вы с коллегой дошли на того решения и архитектуры, которое продемонстрировали на 6 уроке. Как рассуждали, от чего отталкивались. Было бы интересно послушать как рождаются такие решения.
2. Техника слушателей, которая была показана - ServerSocketThreadListener и SocketThreadListener - как ими управлять, останавливать, обрабатывать? Реализовывать методы интерфейса? Подобный поход - это базовый подход к клиент-серверному взаимодействию?
3. Не совсем понятно, как правильно работать с IN / OUT при закрытии сокета, на каком уровне нужно и нужно ли их закрывать?
4. Вкратце, есть ли готовые, коробочные варианты подобной реализации, какие то фреймворки / библиотеки?

ClientGui:
1. строка 46 Thread.setDefaultUncaughtExceptionHandler(this); - что это?
2. строка 48 setLocationRelativeTo(null); - что это?
3. строка 110 socketThread.sendMessage(msg); - как работает метод?
4. строка 135 showException(Thread t, Throwable e) - как работает метод,
ChatServer:
1. строка 18 server = new ServerSocketThread(this, "Server", port, 2000); - почему передаем this
ServerGUI:
1. строка 59 uncaughtException(Thread t, Throwable e) - как работает метод

1. Что и прикаких обстоятельствах может пойти не так, если убрать flush? Я убрал, запустил, все работает.
2. Хотел бы вернуться к вопросу о synchronized методах: https://prnt.sc/rles0v. На сервере будет много объектов типа SocketThread, - это я понимаю. Не понимаю, какие могут быть между ними конфликты. Ведь они будут писать каждый в свою копию DataOutputStream out, и метод close() будет вызываться на каждом из этих объектов независимо от других. Все выглядит так, что тут нет разделяемых даных, и зачем тогда синхронизация?

можно ли во время урока еще раз показать, как передается сообщение от момента нажатия на кнопку и до получения ответа от сервера в чате?

Когда я создаю свой новый проект (потом пакеты, классы и т.п.), то все работает как положено,
но как только открываю сторонний код (например, код с урока), то он после открытия не запускаются,
RUN выполнить не могу и поэтому приходится постоянно все уроки копировать в свои новосозданные проекты,
чтобы запустить код на выполнение (возможно, что так и все это делают всегда. Или нет?)

В Server GUI строка: btnStart.addActionListener(this); в роли какого параметра выступает this?
При попытке остановить сервер сообщение "server stopped" выводится дважды. Почему?
ClientGUI. Строка if ("".equals(msg)) return; Что она возвращает? (см. далее вопрос 3)

Вопрос по дженерикам, добавил дженерик в Вектор, и все срослось с массивом, добавление нитей и рассылка всем пользователям, но точно как работает, не совсем догоняю

1) Более подробно расскажите как проходит разработка архитектуры приложения до того как начинается писаться код.
2) Созданы два интерфейса ServerSocketThreadListener и SocketThreadListener. У них одинаковые методы, почему нельзя сделать один общий интерфейс ThreadListener?
3) Взаимодействие inputStream и outputStream у Socket и ServerSocket не совсем понял. Какая логика их взаимодействия более подробно объясните пожалуйста.

Как server.accept() помещается в отдельный тред? Автоматически?
Зачем нам ServerSocketThread и SocketThread? Они же универсальные. Почему нельзя обойтись одним классом?

1.Почему мы в конструкторе (например, в SocketThread) параметр name помещаем в super, а остальные в this. Нельзя все в супер запихнуть?
2. В классе SocketThread метод run: пишем listener.onSocketStart(this, socket), НО listener.onSocketStop(this) - не нужно передавать в стопе, какой именно сокет был остановлен?
3. Почему метод public synchronized boolean sendMessage именно булевый? Мы можем возвращать тот же msg в случае успеха и ничего не возвращать в случае провала?
5. Не разобрался, зачем continue в SocketTimeoutException

сейчас, когда мы адресуем сообщение серверу, он нам отвечает через echo, т.е. дает понять, что сообщение получил и может его обрабатывать. Когда мы будем общаться с кем-либо живым посредством чата, получается, что один серверный сокет будет взаимодействовать с двумя клиентами одновременно, являясь для них чем-то вроде мостика?

1) Предполагается, что "ClientGUI.java" может запустить несколько пользователей. Как запустить файл в IDEA несколько раз?

2) При нажатии на кнопку "Login" выполняется:

   private void connect() {
       try {
           Socket socket = new Socket(tfIPAddress.getText(), Integer.parseInt(tfPort.getText()));
           socketThread = new SocketThread(this, "Client", socket);
       } catch (IOException e) {
           showException(Thread.currentThread(), e);
       }
   }
   Логин пользователя - название потока. То есть, каждый логин должен быть уникальным?

3) Vector нужно использовать, чтобы передавать логин и текст?

Вопросы скорее по практике применения модулей в реальной жизни: как лучше разбивать проекты на эти модули (по функционалу я понимаю - а если у них функционал пересекается? мы используем повторяющийся код в двух разных модулях или делаем связь в виде ссылок? ) ? Иногда возникали проблемы с запаковкой в jar ( но это было после ИК, сейчас возможно таких проблем не будет) , если будет возможность покажите нюансы которые могут возникать.
В курсе были вещи которые вы говорили всегда должны быть в голове у разработчика несмотря на отсутствие в ТЗ , нет ли списка таких вещей или таблички?
Вопросы про мониторы, как определять места для их расстановки при многопоточности? например если мы делим передачу файлов на несколько потоков, как избежать мешанины в передааваемых данных при этом добиться увелечения скорости разбивки файла на передаваемые байты?
Необходимо ли делать проверку занятости порта перед созданием там сокета? Подобием пинга с запросам ответа в виде буалена?
Чем обусловлена необходимость в интерфейсах прописывать параметры, которые по факту в обработчике листенера не используются, более того, как правило, они листенером же и создаются и управляются?

И еще, зачем по большому счету нужны такие методы интерфейса как onServerStart(), onServerStop() – они ведь, получается, дублируют события, которые мы сами и инициируем в том потоке, который использует нашу «библиотеку»

1) По серверу - я правильно понимаю, что мы реализовали паттерн синглтон в public void start в ChatServer? Т.е. мы первый раз инициируем создание экземпляра, а дальше проверяет, создан ли он. Если создан, то используем созданый. Верно?
2) Прошу повторить насчет интерфейсов - они необходимы для того, чтобы обязать нас реолизовывать определенный набор методов? В этом их задача?

каждая строчка кода вроде сама по себе понятна, но вот их взаимодействие не складывается в общую картину.
* */
